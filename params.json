{"name":"Cron","tagline":"Job scheduling for Laravel","body":"# ![alt text](https://raw.github.com/liebig/cron/master/icon.png \"Cron\") Cron ![project status](http://stillmaintained.com/liebig/cron.png)\r\nJob scheduling for Laravel\r\n\r\nCron can be used for easily performing cron jobs in Laravel without using Artisan commands. The Cron way is to define a route which is called a variable number of minutes (default is every minute - * * * * *). To this route definition add your functions with their cron expressions. Each time the cron route is called, all cron jobs with a suitable cron expression will be called as well. And that is the Cron magic! Additionally Cron logs every run with the error jobs into the database for you and if you wish into a Monolog logger instance. This cron package is a holistic cron manager for your Laravel website.  \r\n\r\n\r\n- [Overview](#overview)\r\n- [Installation](#installation)\r\n- [Usage](#usage)\r\n- [|--Add a cron job](#addjob)\r\n- [|--Remove a cron job](#removejob)\r\n- [|--Enable / disable a cron job](#enabledisable)\r\n- [|--Run the cron jobs](#runjob)\r\n- [|--Enable / disable Laravel logging](#enablelarvellogging)\r\n- [|--Set a Monolog logger](#setlogger)\r\n- [|--Disable database logging](#disabledatabaselogging)\r\n- [|--Log only error jobs to database](#logonlyerrorjobstodatabase)\r\n- [|--Delete old database entries](#deleteolddatabaseentries)\r\n- [|--Prevent overlapping](#preventoverlapping)\r\n- [|--Reset Cron](#reset)\r\n- [|--Changing default values](#defaultvalues)\r\n- [Full example](#fullexample)\r\n- [Changelog](#changelog)\r\n\r\n---\r\n\r\n<a name=\"overview\"></a>\r\n## Overview\r\n\r\nYou have to\r\n*   ... download this package\r\n*   ... define a route with all cron job definitions, closing with the `run()` method call\r\n*   ... buy or rent a server or service which call the defined cron route every predefined number of minutes (default is every minute) as normal a web request (e.g. with wget)\r\n\r\nYou don't have to\r\n*   ... create Artisan commands\r\n*   ... own shell access to your server\r\n*   ... run the regular cron route requests on the same machine where your Laravel site is located\r\n*   ... worry about (cron) job management anymore\r\n\r\n**NOTE**: If you have any trouble, questions or suggestions just open an issue. It would be nice to hear from you.\r\n\r\n---\r\n\r\n<a name=\"installation\"></a>\r\n## Installation\r\n\r\n1.  Add `\"liebig/cron\": \"dev-master\"` to your `/laravel/composer.json` file at the `\"require\":` section (Find more about composer at http://getcomposer.org/)\r\n2.  Run the `composer update --no-dev` command in your shell from your `/laravel/` directory \r\n3.  Add `'Liebig\\Cron\\CronServiceProvider'` to your `'providers'` array in the `app\\config\\app.php` file\r\n4.  Migrate the database with running the command `php artisan migrate --package=\"liebig/cron\"`\r\n5.  Publish the configuration file with running the command `php artisan config:publish liebig/cron` - now you find the Cron configuration file in `/laravel/app/config/packages/liebig/cron` and this file won't be overwritten at any update\r\n6.  Now you can use `Cron` everywhere for free\r\n\r\n**NOTE**: Since version v0.9.3 you can use `Cron` instead of `\\Liebig\\Cron\\Cron`\r\n\r\n---\r\n\r\n<a name=\"usage\"></a>\r\n## Usage\r\n\r\n<a name=\"addjob\"></a>\r\n### Add a cron job\r\n\r\nAdding a cron job to Cron is very easy by using the static **add** function. As parameter the **name** of the cron job, the cron **expression** and an anonymous **function** is needed. The boolean **isEnabled** is optional and can enable or disable this cron job execution (default is enabled).\r\n\r\n```\r\npublic static function add($name, $expression, $function, $isEnabled = true) {\r\n```\r\n\r\nThe **name** is needed for identifying a cron job if an error appears and for logging.\r\n\r\nThe **expression** is a string of five or optional six subexpressions that describe details of the schedule. The syntax is based on the Linux cron daemon definition.\r\n```\r\n    *    *    *    *    *    *\r\n    -    -    -    -    -    -\r\n    |    |    |    |    |    |\r\n    |    |    |    |    |    + year [optional]\r\n    |    |    |    |    +----- day of week (0 - 7) (Sunday=0 or 7)\r\n    |    |    |    +---------- month (1 - 12)\r\n    |    |    +--------------- day of month (1 - 31)\r\n    |    +-------------------- hour (0 - 23)\r\n    +------------------------- min (0 - 59)\r\n```\r\n\r\nThe given anonymous **function** will be invoked if the expression details match with the current timestamp. This function should return null in the case of success or anything else if there was an error while executing this job. By default, the error case will be logged to the database and to a Monolog logger object (if logger is enabled). \r\n\r\nThe **isEnabled** boolean parameter makes it possible to deactivate a job from execution without removing it completely. Later the job execution can be enabled very easily by giving a true boolean to the method. This parameter is optional and the default value is enabled.\r\n\r\n#### Example\r\n\r\n```\r\nCron::add('example1', '* * * * *', function() {\r\n                    // Do some crazy things successfully every minute\r\n                    return null;\r\n                });\r\nCron::add('example2', '*/2 * * * *', function() {\r\n                    // Oh no, this job has errors and runs every two minutes\r\n                    return false;\r\n                }, true);\r\n```\r\n\r\n---\r\n\r\n<a name=\"removejob\"></a>\r\n### Remove a cron job\r\n\r\nTo remove a set cron job on runtime use the **remove** method with the cron job name as string parameter.\r\n\r\n```\r\npublic static function remove($name) {\r\n```\r\n\r\n#### Example\r\n\r\n```\r\nCron::add('example1', '* * * * *', function() {\r\n                    // Do some crazy things successfully every minute\r\n                    return null;\r\n                });\r\nCron::remove('example1');\r\n```\r\n\r\n---\r\n\r\n<a name=\"enabledisable\"></a>\r\n### Enable or disable a cron job \r\n\r\nAfter adding an enabled or disabled cron job ($isEnabled boolean parameter of the add method call) you can disable or enable a cron job by name. For this use the **setEnableJob** or **setDisableJob** function.\r\n\r\n```\r\npublic static function setEnableJob($jobname, $enable = true) {\r\n```\r\n```\r\npublic static function setDisableJob($jobname) {\r\n```\r\n\r\n#### Example\r\n\r\n```\r\nCron::add('example1', '* * * * *', function() {\r\n                    // Do some crazy things successfully every minute\r\n                    return null;\r\n                });\r\nCron::setDisableJob('example1');\r\n// No jobs will be called\r\n$report = Cron::run();\r\nCron::setEnableJob('example1');\r\n// One job will be called\r\n$report = Cron::run();\r\n```\r\n\r\n#### Getter\r\n\r\nTo receive the enable status boolean of a job, use the static `isJobEnabled($jobname)` method.\r\n\r\n---\r\n\r\n\r\n<a name=\"runjob\"></a>\r\n### Run the cron jobs\r\n\r\nRunning the cron jobs is as easy as adding them. Just call the static **run** method and wait until each added cron job expression is checked. As soon as the time of the expression has come, the corresponding cron job will be invoked. That is the Cron magic. The **run** method returns a detailed report. By default Cron reckons that you call this method every minute (* * * * *) and by default the report (with their cron jobs errors) will be logged to database. You can change this interval using the `setRunInterval` function.\r\n\r\n```\r\npublic static function run() {\r\n```\r\n\r\n#### Example\r\n\r\n```\r\n$report = Cron::run();\r\n```\r\n\r\n**NOTE**: The **run** method call has to be the last function call after adding jobs, setting the interval, deactivating database logging and the other function calls.\r\n\r\n---\r\n\r\n### Set the run interval\r\n\r\nThe run interval is the time between two cron job route calls. Some cron service provider only supports calls every 15 or even 30 minutes. In this case you have to set this value to 15 or 30. This value is only important to determine if the current run call is in time. If you have disabled database logging in general, you don't have to care about this.\r\n\r\n```\r\npublic static function setRunInterval($minutes) {\r\n```\r\n\r\n**NOTE**: If the route call interval is not every minute you have to adjust your cron job expressions to fit to this interval.\r\n\r\n#### Example\r\n\r\n```\r\n// Set the run intervall to 15 minutes\r\nCron::setRunInterval(15);\r\n// Or set the run intervall to 30 minutes\r\nCron::setRunInterval(30);\r\n```\r\n\r\n#### Getter\r\n\r\nTo recieve the current set run interval use the static `getRunInterval()` method.\r\n\r\n---\r\n\r\n<a name=\"enablelarvellogging\"></a>\r\n### Enable or disable Laravel logging\r\n\r\nThe Laravel logging facilities provide a layer on top of Monolog. By default, Laravel is configured to create daily log files for your application, and these files are stored in `app/storage/logs`. Cron will use Laravel logging facilities by default. You can disable this by setting the `laravelLogging` config.php value to false or call at runtime the **setLaravelLogging** function.\r\n\r\n```\r\npublic static function setLaravelLogging($bool) {\r\n```\r\n\r\n**NOTE**: You can add a custom Monolog logger to Cron and enable Laravel logging. In this case all messages will be logged to Laravel and to your custom Monolog logger object.\r\n\r\n#### Example\r\n\r\n```\r\n// Laravel logging is enabled by default\r\nCron::run();\r\n// Disable Laravel logging\r\nCron::setLaravelLogging(false);\r\n// Laravel logging is disabled\r\nCron::run();\r\n```\r\n\r\n#### Getter\r\n\r\nTo recieve the enabled or disabled boolean value use the static `isLaravelLogging()` method.\r\n\r\n---\r\n\r\n\r\n<a name=\"setlogger\"></a>\r\n### Set a Monolog logger\r\n\r\nIf you want to add a custom Monolog logger object to Cron use the static **setLogger** method.\r\n\r\n```\r\npublic static function setLogger(\\Monolog\\Logger $logger = null) {\r\n```\r\n\r\n**NOTE**: If you want to remove the logger, just call the **setLogger** method without parameters.\r\n\r\n#### Example\r\n\r\n```\r\nCron::setLogger(new \\Monolog\\Logger('cronLogger'));\r\n// And remove the logger again\r\nCron::setLogger();\r\n```\r\n\r\n#### Getter\r\n\r\nTo recieve the set logger object use the static `getLogger()` method. If no logger object is set, null will be returned. \r\n\r\n---\r\n\r\n<a name=\"disabledatabaselogging\"></a>\r\n### Disable database logging\r\n\r\nBy default database logging is enabled and after each cron run a manager object and job objects will be saved to database. We strongly recommend to keep the database logging activated because only with this option Cron can check if the current run is in time. It could make sense in some cases to deactivate the database logging with the **setDatabaseLogging** method.\r\n\r\n```\r\npublic static function setDatabaseLogging($bool) {\r\n```\r\n\r\n#### Example\r\n\r\n```\r\nCron::setDatabaseLogging(false);\r\n```\r\n\r\n#### Getter\r\n\r\nTo receive the current boolean value of the logging to database variable, just use the static `isDatabaseLogging()` function.\r\n\r\n---\r\n\r\n<a name=\"logonlyerrorjobstodatabase\"></a>\r\n### Log only error jobs to database\r\n\r\nBy default Cron will only log error jobs (which not return null) to database. Maybe you want to log all run jobs to database by using the static **setLogOnlyErrorJobsToDatabase** function. \r\n\r\n```\r\npublic static function setLogOnlyErrorJobsToDatabase($bool) {\r\n```\r\n\r\n#### Example\r\n\r\n```\r\n// Log all jobs (not only the error jobs) to database\r\nCron::setLogOnlyErrorJobsToDatabase(false);\r\n```\r\n\r\n#### Getter\r\n\r\nTo receive the current boolean value of the logging only error jobs to database variable, just use the static `isLogOnlyErrorJobsToDatabase()` function.\r\n\r\n---\r\n\r\n<a name=\"deleteolddatabaseentries\"></a>\r\n### Delete old database entries\r\n\r\nCron can delete old database entries for you. During each run method call, Cron checks if there are old manager and job entries in the database and if the reference value is reached, the entries will be deleted. You can change the reference value by calling the **setDeleteDatabaseEntriesAfter** function. The default value is 240 hours (10 days). To disable the deletion of old entries just set the reference value to 0.\r\n\r\n```\r\npublic static function setDeleteDatabaseEntriesAfter($hours) {\r\n```\r\n\r\n#### Example\r\n\r\n```\r\n// Set the delete database entries reference value to 10 days (24 hours x 10 days)\r\nCron::setDeleteDatabaseEntriesAfter(240);\r\n```\r\n\r\n#### Getter\r\n\r\nTo receive the current reference value just use the static `getDeleteDatabaseEntriesAfter` function.\r\n\r\n---\r\n\r\n<a name=\"preventoverlapping\"></a>\r\n### Prevent overlapping\r\n\r\nCron can prevent job overlapping. If this is enabled, only one Cron instance can run at the same time. For example if some jobs need 5 minutes for execution but the Cron route will be called every minute, without preventing overlapping two Cron instances will execute jobs at the same time. When running a job twice at the same time, side effects can come up. Cron can avoid such overlaps by using simple locking techniques.\r\n\r\n```\r\npublic static function setEnablePreventOverlapping() {\r\n```\r\n\r\n#### Example\r\n\r\n```\r\n// The configuration could be set via config.php file with the key 'preventOverlapping' or via method\r\nCron::setEnablePreventOverlapping();\r\n// Now the Cron run will only run once at the same time\r\n\r\nCron::setDisablePreventOverlapping();\r\n// Prevent overlapping is disabled and many Cron run executions are possible at the same time\r\n```\r\n\r\n#### Getter\r\n\r\nTo receive the current boolean value just use the static `isPreventOverlapping` function.\r\n\r\n**NOTE**: To use the overlapping functionality, Cron needs write access to the Laravel storage directory.\r\n\r\n---\r\n\r\n<a name=\"reset\"></a>\r\n### Reset Cron\r\n\r\nTo reset the cron management, call the static **reset** method. It will reset all variables to the default values.\r\n\r\n```\r\npublic static function reset() {\r\n```\r\n\r\n#### Example\r\n\r\n```\r\nCron::add('example1', '* * * * *', function() {\r\n                    // Do some crazy things successfully every minute\r\n                    return null;\r\n                });\r\nCron::setLogger(new \\Monolog\\Logger('cronLogger'));\r\nCron::reset();\r\n// Cron::remove('example1') === false\r\n// Cron::getLogger() === NULL\r\n```\r\n\r\n---\r\n\r\n<a name=\"defaultvalues\"></a>\r\n### Changing default values\r\n\r\nCron is designed to work out of the box without configuration. To enable this behaviour a few default values are set. To change Crons default settings there are two possibilities.\r\n\r\n#### Set methods\r\n\r\nYou can use the Cron set methods (e.g. setDatabaseLogging, setRunInterval) to change the behaviour. This changes are temporary and the set methods has to be called every time before running the **run** method. \r\n\r\n#### Config file\r\n\r\nThe behaviour values will be loaded from a Cron config file. You can change this values easily by editing the `src/config/config.php` file. This is the more permanent way. If you only want to change settings for one run, we recommend to use the setter methods.\r\n\r\n---\r\n\r\n<a name=\"fullexample\"></a>\r\n## Full example\r\n\r\nAt first we create a route which should be called in a defined interval.\r\n\r\n**NOTE**: We have to protect this route because if someone calls this uncontrolled, our cron management doesn't work. A possibility is to set the route path to a long value. Another good alternative is (if you know the IP address of the calling server) to check if the IP address matchs.\r\n\r\n```\r\nRoute::get('/Cron/run/c68pd2s4e363221a3064e8807da20s1sf', function () {\r\n\r\n});\r\n```\r\n\r\nNow we can add our cron jobs to this route and of course call the run method. At the end we print out the report.\r\n\r\n```\r\nRoute::get('/cron/run/c68pd2s4e363221a3064e8807da20s1sf', function () {\r\n    Cron::add('example1', '* * * * *', function() {\r\n                        // Do some crazy things every minute\r\n                        return null;\r\n                    });\r\n    Cron::add('example2', '*/2 * * * *', function() {\r\n                        // Do some crazy things every two minutes\r\n                        return null;\r\n                    });\r\n    $report = Cron::run();\r\n    print_r ($report);\r\n});\r\n```\r\n\r\nAnd that is the Cron magic. Now we have to ensure that this route is called in an interval. This can be done with renting an own (virtual) server or with an online cronjob service. In both cases Google knows many good providers. An online cronjob service overview can be found at http://www.cronjobservices.com/\r\n\r\nTo configure a `wget` web request by using `crontab -e` or a control panel software (e.g. cPanel or Plesk) on an own (virtual) server use the following code:\r\n\r\n```\r\n* * * * * wget -O - http://yoursite.com/cron/run/c68pd2s4e363221a3064e8807da20s1sf >/dev/null 2>&1\r\n```\r\n\r\nFor using `cURL` instead of wget on your server use this code:\r\n\r\n```\r\n* * * * * curl \"http://yoursite.com/cron/run/c68pd2s4e363221a3064e8807da20s1sf\" >/dev/null 2>&1\r\n```\r\n\r\nThe starting five asterisks are the cron expressions. We want to start our Cron management every minute in this example. The tool `wget` retrieves files using HTTP, HTTPS and FTP. Using the parameter `-O -` causes that the output of the web request will be sent to STDOUT (standard output). `cURL` is a command line tool for getting or sending files using URL syntax. By adding `>/dev/null` we instruct standard output to be redirect to a black hole (/dev/null). By adding `2>&1` we instruct STDERR (standard errors) to also be sent to STDOUT (in this example this is /dev/null). So it will load our website at the Cron route every minute, but never write a file anywhere.\r\n\r\n---\r\n\r\n<a name=\"changelog\"></a>\r\n## Changelog\r\n\r\n### 2014/02/11 - v0.9.5\r\n* Bug fixing release\r\n* Fixing bug with PSR0 Autoloading\r\n* Fixing time bug - if a job took more than one minute for execution the following jobs were not handled\r\n\r\n### 2013/11/12 - v0.9.4\r\n* Added Laravel logging facilities - by default Cron will log to Laravel now\r\n* Added Exceptions - Cron will throw InvalidArgumentExceptions and UnexpectedValueExceptions now\r\n* Minor bug fixes\r\n\r\n### 2013/11/01 - v0.9.3\r\n* Added facade for Cron - you can use `Cron` instead of `\\Liebig\\Cron\\Cron` now\r\n* Added facade test cases\r\n\r\n---\r\n\r\n## License\r\n\r\nThe MIT License (MIT)\r\n\r\nCopyright (c) 2014 Marc Liebig\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in\r\nall copies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\nTHE SOFTWARE.\r\n\r\nIcon Copyright (c) Timothy Miller (http://www.iconfinder.com/icondetails/171279/48/alarm_bell_clock_time_icon) under Creative Commons (Attribution-Share Alike 3.0 Unported) License - Thank you for this awesome icon","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}